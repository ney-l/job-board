# About

TO DO ...

## Tech Stack

Below is the tech stack that will be used to build this project, along with justifications for each tool or technology.

### Next.js

#### Why Next.js?

Next.js is a powerful React framework that abstracts complexities away from developers and allows for easy and efficient creation of modern web applications. Next.js offers multiple rendering strategies, including client-side rendering, server-side rendering, static site generation, and incremental static regeneration. It also allows for performance optimization through techniques such as code splitting, lazy loading, prefetching, and image optimization.

### TypeScript

#### Why TypeScript?

TypeScript is a popular superset of JavaScript that offers many benefits, especially for large applications. Code written in TypeScript is better documented than code written in vanilla JS, allowing for easier maintenance and refactoring. TypeScript also helps boost code editor's IntelliSense for intelligent code completion, hover information, signature information, and more, thereby improving productivity.

### ESLint

#### Why ESLint?

ESLint is a popular linting tool for JavaScript/TypeScript that analyzes source code and detects potential issues in the codebase. It can be configured with different plugins and rules to adapt the linter to the application's specific needs, thereby ensuring code quality and consistency.

### Prettier

#### Why Prettier?

Prettier is a great tool for formatting code in a consistent manner across the entire codebase. It enforces a consistent coding style, which is important for maintainability and readability.

### Husky

#### Why Husky?

Husky is a tool that enables static code analysis checks to run automatically before committing to the repository. This helps ensure that code quality and consistency are maintained throughout the project.

### PNPM

#### Why PNPM?

PNPM is a package manager that offers several advantages over other package managers such as npm and Yarn. PNPM provides faster installation and updates, reduced disk space usage, and improved security. It achieves these benefits by using a shared cache for dependencies, which means that if multiple projects use the same dependencies, they only need to be installed once. This can greatly reduce installation and update times, especially for large projects with many dependencies. PNPM also automatically verifies the integrity of dependencies during installation, which can help prevent security vulnerabilities from being introduced into the project.
